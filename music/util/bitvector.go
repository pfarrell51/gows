// simple bit vector. prototype generated by Google's search AI

package util

import (
	"fmt"
)

type BitVector struct {
	store []uint64
	max   int
}

func NewBitVector(size int) BitVector {
	var rval *BitVector
	rval = new(BitVector)
	rval.store = make([]uint64, (size+63)/64)
	rval.max = size
	return *rval
}

func (bv BitVector) Set(i int) {
	if i >= bv.max {
		panic(fmt.Sprintf("bitvector set max index error %d >= %d", i, bv.max))
	}
	bv.store[i/64] |= 1 << (i % 64)
}

func (bv BitVector) Get(i int) bool {
	if i >= bv.max {
		panic(fmt.Sprintf("bitvector get max index error %d >= %d", i, bv.max))
	}
	return bv.store[i/64]&(1<<(i%64)) != 0
}
func (bv BitVector) Size() int {
	return bv.max
}
func (bv BitVector) FirstRun(idx int) []int {
	if idx >= bv.max {
		errRtn := []int{}
		return errRtn
	}
	var start, stop int = -1, -1
	var possRun, inRun bool
	var lowLoop = 0
	if idx > -1 {
		lowLoop = idx
	}
	for i := lowLoop; i < bv.max; i++ {
		if bv.Get(i) {
			possRun = true
			switch {
			case possRun && !inRun:
				inRun = true
				start = i
			case inRun:
				stop = i
			default:
				fmt.Println("default triggered")
			}
		} else {
			if start >= lowLoop && stop > lowLoop {
				rval := []int{start, stop}
				return rval
			}
			inRun = false
			possRun = false
		}
	}
	rtn := []int{}
	return rtn
}

// ... other operations like Clear, Toggle, etc.
