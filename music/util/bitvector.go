// simple bit vector. prototype generated by Google's search AI

package util

import (
	"fmt"
)

type BitVector struct {
	store []uint64
	max   int
}

func NewBitVector(size int) BitVector {
	var rval *BitVector
	rval = new(BitVector)
	rval.store = make([]uint64, (size+63)/64)
	rval.max = size
	return *rval
}

func (bv BitVector) Set(i int) {
	if i >= bv.max {
		panic(fmt.Sprintf("bitvector set max index error %d >= %d", i, bv.max))
	}
	bv.store[i/64] |= 1 << (i % 64)
}
func (bv BitVector) Clear(i int) {
	if i >= bv.max {
		panic(fmt.Sprintf("bitvector  max index error %d >= %d", i, bv.max))
	}
	bv.store[i/64] =  bv.store[i/64] &^ (uint64)( 1 << (i % 64))
}

func (bv BitVector) Get(i int) bool {
	if i >= bv.max {
		panic(fmt.Sprintf("bitvector get max index error %d >= %d", i, bv.max))
	}
	return bv.store[i/64]&(1<<(i%64)) != 0
}
func (bv BitVector) Size() int {
	return bv.max
}
func (bv BitVector) LogicalInvert() BitVector {
	var rval = NewBitVector(bv.max)
	for i := 0; i < len(bv.store); i++ {
		rval.store[i] = ^uint64(bv.store[i])
		fmt.Printf("(%064X)", rval.store[i])
	}
	return rval
}

// return a array of arrays of the positions that are TRUE
func (bv BitVector) AllTrue() [][]int {
	rval := [][]int{}
	var start, stop int = -1, -1
	var inRun bool
	for i := 0; i < bv.max; i++ {
		if bv.Get(i) {
			switch {
			case !inRun:
				inRun = true
				start = i
				stop = i + 1
			case inRun:
				stop = i + 1
			default:
				fmt.Println("default triggered")
			}
			if inRun && i+1 == bv.max {
				row := []int{start, stop} // last character is OK.
				rval = append(rval, row)
			}
		} else {
			//	fmt.Printf("Off i: %d, ir %t, start: %d, stop %d\n", i, inRun, start, stop)
			if inRun {
				if start >= 0 && stop >= 0 {
					row := []int{start, stop}
					rval = append(rval, row)
				}
			}
			inRun = false
		}
	}
	return rval
}
func printRval(idx int, rval [][]int) {
	fmt.Printf("number rows %d\n", len(rval))
	for i, row := range rval {
		fmt.Printf("i: %d len=%d cap=%d %v\n", i, len(row), cap(row), row)
	}
}
func (bv BitVector) FirstRun(idx int) []int {
	if idx >= bv.max {
		errRtn := []int{}
		return errRtn
	}
	var start, stop int = -1, -1
	var possRun, inRun bool
	var lowLoop = 0
	if idx > -1 {
		lowLoop = idx
	}
	for i := lowLoop; i < bv.max; i++ {
		if bv.Get(i) {
			possRun = true
			switch {
			case possRun && !inRun:
				inRun = true
				start = i
			case inRun:
				stop = i
			default:
				fmt.Println("default triggered")
			}
		} else {
			if start >= lowLoop && stop > lowLoop {
				rval := []int{start, stop}
				return rval
			}
			inRun = false
			possRun = false
		}
	}
	rtn := []int{}
	return rtn
}

// ... other operations like Clear, Toggle, etc.
